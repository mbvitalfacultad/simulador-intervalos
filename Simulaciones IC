streamlit_app.py

import streamlit as st
import numpy as np
import pandas as pd
import altair as alt
from scipy.stats import norm, t, chi2, binom

st.set_page_config(page_title="Simulador de Intervalos de Confianza", layout="wide")

st.title("ðŸ“Š Simulador de Intervalos de Confianza")
st.markdown("""
ExplorÃ¡ visualmente cÃ³mo se comportan los intervalos de confianza para:
- Media (Ïƒ conocida)
- Media (Ïƒ desconocida)
- Varianza
- ProporciÃ³n muestral

Inspirado en [rpsychologist.com](https://rpsychologist.com/d3/ci/).
""")

tipo = st.sidebar.selectbox("Tipo de intervalo",
    ["Media (Ïƒ conocida)", "Media (Ïƒ desconocida)", "Varianza", "ProporciÃ³n"]
)

n = st.sidebar.slider("TamaÃ±o muestral (n)", 5, 500, 30)
conf = st.sidebar.slider("Nivel de confianza (%)", 80, 99, 95) / 100
reps = st.sidebar.slider("NÃºmero de simulaciones", 10, 200, 50)

mu = st.sidebar.number_input("Media poblacional (Î¼)", value=0.0)
sigma = st.sidebar.number_input("DesvÃ­o estÃ¡ndar poblacional (Ïƒ)", value=1.0, min_value=0.1)
p = st.sidebar.slider("ProporciÃ³n poblacional (p)", 0.0, 1.0, 0.5)

alpha = 1 - conf
yes = []
low, high = [], []

for i in range(reps):
    if tipo in ["Media (Ïƒ conocida)", "Media (Ïƒ desconocida)"]:
        sample = np.random.normal(mu, sigma, n)
        xbar = np.mean(sample)
        if tipo == "Media (Ïƒ conocida)":
            se = sigma / np.sqrt(n)
            z = norm.ppf(1 - alpha/2)
            lo, hi = xbar - z*se, xbar + z*se
        else:
            s = np.std(sample, ddof=1)
            se = s / np.sqrt(n)
            t_val = t.ppf(1 - alpha/2, df=n-1)
            lo, hi = xbar - t_val*se, xbar + t_val*se
        true_val = mu

    elif tipo == "Varianza":
        sample = np.random.normal(mu, sigma, n)
        s2 = np.var(sample, ddof=1)
        ch_low = chi2.ppf(1 - alpha/2, df=n-1)
        ch_hi = chi2.ppf(alpha/2, df=n-1)
        lo = (n-1)*s2/ch_low
        hi = (n-1)*s2/ch_hi
        true_val = sigma**2

    else:  # ProporciÃ³n
        sample = binom.rvs(1, p, size=n)
        phat = np.mean(sample)
        se = np.sqrt(phat*(1-phat)/n)
        z = norm.ppf(1 - alpha/2)
        lo, hi = max(0, phat - z*se), min(1, phat + z*se)
        true_val = p

    low.append(lo); high.append(hi); yes.append(lo <= true_val <= hi)

df = pd.DataFrame({
  "SimulaciÃ³n": range(1, reps+1),
  "LÃ­mite inferior": low,
  "LÃ­mite superior": high,
  "Contiene verdadero": yes
})

intervals = alt.Chart(df).mark_rule(size=2).encode(
    x="LÃ­mite inferior:Q", x2="LÃ­mite superior:Q", y=alt.Y("SimulaciÃ³n:O", sort="descending"),
    color=alt.condition("datum['Contiene verdadero']", alt.value("black"), alt.value("red"))
)

true_line = alt.Chart(pd.DataFrame({"valor": [true_val]})).mark_rule(strokeDash=[5,5], color="blue").encode(x="valor:Q")

chart = (intervals + true_line).properties(width=700, height=500, title=f"{int(conf*100)} % ICs â€“ {tipo}").configure_axis(grid=False).configure_view(strokeWidth=0).configure_title(fontSize=16, anchor="start")

st.altair_chart(chart, use_container_width=True)

perc = sum(yes) / reps * 100
st.markdown(f"**Cobertura**: {sum(yes)}/{reps} intervalos â†’ **{perc:.1f}%** contienen el valor verdadero ({true_val:.3f})")
